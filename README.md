# WMR SMC Project – TurtleBot3 + ROS2 + NSMC / BSMC
This project implements and compares two control laws for a differential wheeled mobile robot (WMR – Wheeled Mobile Robot):

- **NSMC** – Novel Sliding Mode Controller  
- **BSMC** – Backstepping Sliding Mode Controller  

## Introduction

This project introduces the implementation of a robust nonlinear control framework designed to ensure stable motion along circular and 8-shaped trajectories. The objective is to provide a practical solution that can be easily implemented with minimum configuration requirements.

## Mathematical Problem Description

We focus on the design and implementation of a robust nonlinear trajectory tracking controller for a mobile robot modeled using the unicycle kinematic model. The controller is validated both in MATLAB simulations and on a TurtleBot3 mobile robot running ROS 2.

### Robot Kinematic Model

The TurtleBot3 is represented by the standard unicycle model:

$$\begin{cases}
\dot{x} = v \cos \theta \\
\dot{y} = v \sin \theta \\
\dot{\theta} = \omega
\end{cases}$$

where:
- $x, y$ are the robot's global coordinates
- $\theta$ is the robot's orientation
- $v$ is the linear velocity input
- $\omega$ is the angular velocity input

This nonlinear model couples translation and orientation, making trajectory tracking a nonlinear control problem.

### Trajectory-Tracking Objective

The objective is to track a time-varying reference trajectory:

$$q_r(t) = \begin{bmatrix} x_r(t) \\ y_r(t) \\ \theta_r(t) \end{bmatrix}$$

by designing control inputs $v(t)$ and $\omega(t)$ such that the tracking error:

$$e(t) = q_r(t) - q(t)$$

satisfies $\lim_{t \to \infty} e(t) = 0$.

Two nonlinear trajectories are studied:
- Circular trajectory
- 8-shape trajectory

### Robustness Requirements

The controller must ensure tracking performance under:
- Model uncertainties (e.g., wheel slip, unmodeled dynamics)
- Sensor noise from odometry
- External disturbances
- Actuation limits (TurtleBot3 velocity bounds)

### Nonlinear Robust Control Formulation
The paper implements a nonlinear robust control law (backstepping, sliding mode, or error feedback linearization depending on the exact formulation), using:

- Error Transformation to Local Frame:

$$\begin{bmatrix} e_x \\ e_y \end{bmatrix} = \begin{bmatrix} \cos\theta & \sin\theta \\\ -\sin\theta & \cos\theta \end{bmatrix} \begin{bmatrix} x_r - x \\\ y_r - y \end{bmatrix}$$

- Lyapunov Stability Condition:

A Lyapunov function $V(e)$ is constructed such that:

$$\dot{V}(e) \leq -\alpha \|e\|^2 + \delta$$

where:
- $\alpha > 0$ determines the convergence rate
- $\delta$ bounds the effect of disturbances

This guarantees Input-to-State Stability (ISS) and robust performance under disturbances.

### Simulation and TurtleBot3 Implementation

The controller is first validated in MATLAB by simulating:

- the nonlinear robot dynamics
- circular and 8-shape trajectories
- external bounded disturbances.

It is then deployed on a TurtleBot3 using ROS 2, receiving localization data from `/odom` and sending velocity commands to `/cmd_vel`.

---
## **Project Structure**

```text
wmr_smc_project/
├── ros2_ws/
│   ├── src/
│   │   ├── wmr_controller/          # ROS2 package – NSMC/BSMC controller
│   │   ├── tb3_explorer/            # (optional) TB3 teleoperation
│   │   └── turtlebot3_simulations/  # TurtleBot3 Gazebo (official clone)
│   ├── build/ install/ log/         # generated by colcon
│
├── matlab/
│   ├── wmr_smc.m                    # reference MATLAB code
│   ├── figures/                     # MATLAB trajectories and plots
│   └── notes/                       # theoretical notes SMC / BSMC
│
├── docs/
│   ├── architecture.md              # ROS2 architecture
│   ├── control_theory.md            # explanation NSMC / BSMC
│   ├── tuning_guide.md              # guide to tune the controller gains
│   └── images/
│
├── scripts/
│   ├── run_tb3_sim.sh               # launches TB3 + Gazebo (empty world)
│   ├── run_wmr_controller.sh        # launches the controller
│   ├── view_rviz.sh                 # launches RViz2 with the paths
│   └── wmr_tuning_helper.py         # helper for tuning gains
│
├── README.md
└── LICENSE
```


## Prerequisites

- Ubuntu 22.04 (Jammy)

- ROS2 Humble installed (`/opt/ros/humble`)

- TurtleBot3 for ROS2:

```bash
sudo apt install -y ros-humble-turtlebot3 ros-humble-turtlebot3-simulations \
ros-humble-gazebo-ros-pkgs
```

**colcon** and **python3-colcon-common-extensions**

RViz2 and Gazebo installed with ROS2

## Installation

```bash
# Clone the repo
git clone https://github.com/thoukam/wmr-robust-smc-controller.git
cd wmr_smc_project/ros2_ws
```

This project depends on two official TurtleBot3 packages for ROS 2 Humble:

- turtlebot3

- turtlebot3_simulations

These packages must exist inside the workspace:


ros2_ws/src/
    ├── turtlebot3/
    ├── turtlebot3_simulations/
    ├── wmr_controller/
    └── ...


They are required for:

the TurtleBot3 URDF description

Gazebo Classic simulation (turtlebot3_gazebo)

fake sensors / dynamics simulation

running the controller on real or simulated robots

⚠️ Important

These packages are NOT included inside the Git repository (because they are large and system-managed).
You must install or place them manually inside ros2_ws/src before building the workspace.

You have two options:

##### Option 1 — Install from system (recommended)

Install the official prebuilt ROS 2 Humble packages:

sudo apt install -y ros-humble-turtlebot3 ros-humble-turtlebot3-simulations


Then link them automatically when sourcing /opt/ros/humble/setup.bash.
No need to clone anything manually.

##### Option 2 — Clone the official repositories (alternative)

If you prefer to compile them yourself:
```bash
cd ros2_ws/src
git clone -b humble-devel https://github.com/ROBOTIS-GIT/turtlebot3.git
git clone -b humble-devel https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git
```
After installing the packages, rebuild:

```bash
# Build the workspace
source /opt/ros/humble/setup.bash
colcon build --symlink-install

# Sourcing (add to your ~/.bashrc if you want)
source /opt/ros/humble/setup.bash
source ~/wmr_smc_project/ros2_ws/install/setup.bash
```

## How to Run the Full Simulation
- Terminal 1 – Launch Gazebo with TurtleBot3
```bash
cd ~/wmr_smc_project
./scripts/run_tb3_sim.sh
```

This starts:

Gazebo

TurtleBot3 Burger

Empty simulation world

- Terminal 2 – Launch the NSMC/BSMC controller
```bash
cd ~/wmr_smc_project
./scripts/run_wmr_controller.sh

//

./scripts/run_wmr_controller.sh BSMC circle

```
You should see real-time logs showing the controller behavior.

- Terminal 3 – Start RViz2 visualization
```bash
cd ~/wmr_smc_project
./scripts/view_rviz.sh
```

**RViz displays**:

- Reference trajectory (/wmr/ref_path)

- Robot trajectory (/wmr/robot_path)

### Controller Parameters

The controller node exposes several ROS2 parameters:

Parameter	Meaning
- controller_type	"NSMC" or "BSMC"
- trajectory	"circle" or "figure8"
- R	Trajectory radius (m)
- Omega	Angular frequency (rad/s)
- Vmax	Linear speed saturation (m/s)
- Wmax	Angular speed saturation (rad/s)
- use_disturbance	Apply disturbance to test robustness (true/false)

Example custom execution:

```bash
ros2 run wmr_controller wmr_controller \
  --ros-args \
    -p controller_type:=NSMC \
    -p trajectory:=circle \
    -p R:=0.6 \
    -p Omega:=0.2 \
    -p Vmax:=0.22 \
    -p Wmax:=1.8 \
    -p use_disturbance:=true
```

MATLAB Reference Model

matlab/wmr_smc.m contains:

A full mathematical implementation of NSMC and BSMC

Exact kinematic WMR model

Circular and lemniscate reference trajectories

Plots for:

tracking errors

control inputs

robot vs reference trajectory

This serves as a ground truth to validate the ROS controller.

## Documentation

The documentation in /docs explains the entire project:

- control_theory.md

Sliding Mode Control basics

NSMC surfaces and design

BSMC derivation

Stability considerations

- **architecture.md**

ROS2 nodes /odom, /cmd_vel, /wmr/ref_path, /wmr/robot_path

Diagram of data flow


Supported Trajectories
✔ Circle

Perfect for stable trajectory tracking tests.

✔ Figure-8 (Lemniscate of Gerono)

More challenging, validates nonlinear behavior and robustness.


# Differences Between NSMC and BSMC

During our simulations, we observed several practical differences between the two controllers:

- NSMC converges faster and corrects errors more aggressively.

- BSMC produces smoother control signals and is less sensitive to noise.

- NSMC achieves higher tracking accuracy, especially on curved trajectories.

- BSMC is more stable for real robots because the control effort is lower.

- NSMC handles strong disturbances better but may oscillate if gains are too high.

- BSMC handles moderate disturbances well while maintaining smooth motion.

In summary:
NSMC is more reactive and precise, while BSMC is smoother and more robust to measurement noise.


# results with matlab

## NSMC

![Description](matlab/figures/trajectoire_figure8_NSMC.png)  ![Description](matlab/figures/trajectoire_circle_NSMC.png)

## BSMC
![Description](matlab/figures/trajectoire_figure8_BSMC.png)   ![Description](matlab/figures/trajectoire_circle_BSMC.png)


# results with ROS2 simulation